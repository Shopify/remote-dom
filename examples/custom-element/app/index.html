<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="https://fav.farm/üõ∞Ô∏è" />
    <title>Custom element ‚Ä¢ Remote DOM</title>
  </head>

  <body>
    <div id="root"></div>

    <!-- The ‚Äúremote‚Äù environment, which we will render in the element above -->
    <iframe id="remote-iframe" src="/remote.html" hidden></iframe>

    <script type="module">
      class UIButton extends HTMLElement {
        // By default, `DOMRemoteReceiver` will assign remote properties as properties,
        // but only if the element has a matching property defined. Otherwise, the remote
        // properties will be set as attributes. We‚Äôll observe the `primary` attribute
        // in order to update our rendered content when that attribute changes. We‚Äôll
        // define a `onClick` method, though, which will be set to the value of the `onClick`
        // remote property.
        static get observedAttributes() {
          return ['primary'];
        }

        connectedCallback() {
          const primary = this.hasAttribute('primary') ?? false;

          const root = this.attachShadow({mode: 'open'});

          // We render a <slot> where we want the element‚Äôs children to go.
          root.innerHTML = `
            <style>
              .Button {
                appearance: none;
                font-size: 1rem;
                padding: 0.5rem 1rem;
                background: transparent;
                border: 1px solid gray;
                border-radius: 0.5rem;
              }

              .Button--primary {
                background: blue;
                color: white;
              }
            </style>
            <button class="Button"><slot></slot></button>
          `;

          if (primary) {
            root.querySelector('.Button').classList.add('Button--primary');
          }
        }

        attributeChangedCallback(name, oldValue, newValue) {
          if (name === 'primary') {
            const button = this.shadowRoot?.querySelector('.Button');

            if (button == null) return;

            if (newValue == null) {
              button.classList.remove('Button--primary');
            } else {
              button.classList.add('Button--primary');
            }
          }
        }

        // Remote DOM will automatically call methods on a custom element to satisfy
        // remote method calls.
        focus() {
          this.shadowRoot.querySelector('button').focus();
        }
      }

      customElements.define('ui-button', UIButton);
    </script>

    <script type="module">
      import {DOMRemoteReceiver} from '@remote-dom/core/receivers';
      import {
        ROOT_ID,
        NODE_TYPE_ELEMENT,
        NODE_TYPE_TEXT,
        NODE_TYPE_COMMENT,
        MUTATION_TYPE_INSERT_CHILD,
        MUTATION_TYPE_UPDATE_TEXT,
        MUTATION_TYPE_UPDATE_PROPERTY,
        MUTATION_TYPE_REMOVE_CHILD,
      } from '@remote-dom/core';
      import {ThreadIframe} from '@quilted/threads';

      const root = document.querySelector('#root');
      const iframe = document.querySelector('#remote-iframe');
      class ProtectedRemoteDOMReceiver extends DOMRemoteReceiver {
        #allowedElements;
        #wrapped = false;
        constructor(options = {}) {
          const {allowedElements = [], ...rest} = options;
          super(rest);
          this.#allowedElements = new Set(allowedElements);
        }

        connect(element) {
          super.connect(element);
          if (this.#wrapped) return;
          this.#wrapped = true;

          const allowedTags = this.#allowedElements;
          const allowedIds = new Set([ROOT_ID]);

          function collectIds(node) {
            const stack = [node];
            while (stack.length > 0) {
              const current = stack.pop();
              if (current && typeof current.id === 'string') {
                allowedIds.add(current.id);
              }
              if (current && current.children) {
                for (const child of current.children) stack.push(child);
              }
            }
          }

          const original = this.connection;
          const filtered = {
            call: (...args) => original.call(...args),
            mutate: (records) => {
              const filteredRecords = [];
              for (const record of records) {
                const [type, ...rest] = record;
                if (type === MUTATION_TYPE_INSERT_CHILD) {
                  const [parentId, child, index] = rest;
                  if (!allowedIds.has(parentId)) continue;
                  if (child.type === NODE_TYPE_ELEMENT) {
                    if (!allowedTags.has(child.element)) continue;
                    collectIds(child);
                  } else if (
                    child.type === NODE_TYPE_TEXT ||
                    child.type === NODE_TYPE_COMMENT
                  ) {
                    if (child && typeof child.id === 'string') {
                      allowedIds.add(child.id);
                    }
                  }
                  filteredRecords.push([type, parentId, child, index]);
                  continue;
                }
                if (type === MUTATION_TYPE_UPDATE_TEXT) {
                  const [id] = rest;
                  if (!allowedIds.has(id)) continue;
                  filteredRecords.push(record);
                  continue;
                }
                if (type === MUTATION_TYPE_UPDATE_PROPERTY) {
                  const [id] = rest;
                  if (!allowedIds.has(id)) continue;
                  filteredRecords.push(record);
                  continue;
                }
                if (type === MUTATION_TYPE_REMOVE_CHILD) {
                  const [parentId] = rest;
                  if (!allowedIds.has(parentId)) continue;
                  filteredRecords.push(record);
                  continue;
                }
                filteredRecords.push(record);
              }
              if (filteredRecords.length > 0) original.mutate(filteredRecords);
            },
          };

          this.connection = filtered;
        }
      }

      const receiver = new ProtectedRemoteDOMReceiver({
        allowedElements: ['ui-button'],
      });
      receiver.connect(root);

      // We use the `@quilted/threads` library to create a ‚Äúthread‚Äù for our iframe,
      // which lets us communicate over `postMessage` without having to worry about
      // most of its complexities. This includes the ability to send functions between
      // environments, which we rely on for the `click` event listener.
      const thread = new ThreadIframe(iframe);

      // We will call the `render` method on the thread, which will send the iframe
      // the `receiver.connection` object. This object, called a `RemoteConnection`,
      // allows the remote environment to synchronize its tree of UI elements into
      // the `root` element we connected our `receiver` to above.
      thread.imports.render(receiver.connection);
    </script>
  </body>
</html>
