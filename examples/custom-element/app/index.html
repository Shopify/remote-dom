<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="https://fav.farm/üõ∞Ô∏è" />
    <title>Custom element ‚Ä¢ Remote DOM</title>
  </head>

  <body>
    <div id="root"></div>

    <!-- The ‚Äúremote‚Äù environment, which we will render in the element above -->
    <iframe id="remote-iframe" src="/remote.html" hidden></iframe>

    <script type="module">
      class UIButton extends HTMLElement {
        // By default, `DOMRemoteReceiver` will assign remote properties as properties,
        // but only if the element has a matching property defined. Otherwise, the remote
        // properties will be set as attributes. We‚Äôll observe the `primary` attribute
        // in order to update our rendered content when that attribute changes. We‚Äôll
        // define a `onClick` method, though, which will be set to the value of the `onClick`
        // remote property.
        static get observedAttributes() {
          return ['primary'];
        }

        connectedCallback() {
          const primary = this.hasAttribute('primary') ?? false;

          const root = this.attachShadow({mode: 'open'});

          // We render a <slot> where we want the element‚Äôs children to go.
          root.innerHTML = `
            <style>
              .Button {
                appearance: none;
                font-size: 1rem;
                padding: 0.5rem 1rem;
                background: transparent;
                border: 1px solid gray;
                border-radius: 0.5rem;
              }

              .Button--primary {
                background: blue;
                color: white;
              }
            </style>
            <button class="Button"><slot></slot></button>
          `;

          if (primary) {
            root.querySelector('.Button').classList.add('Button--primary');
          }
        }

        attributeChangedCallback(name, oldValue, newValue) {
          if (name === 'primary') {
            const button = this.shadowRoot?.querySelector('.Button');

            if (button == null) return;

            if (newValue == null) {
              button.classList.remove('Button--primary');
            } else {
              button.classList.add('Button--primary');
            }
          }
        }

        // Remote DOM will automatically call methods on a custom element to satisfy
        // remote method calls.
        focus() {
          this.shadowRoot.querySelector('button').focus();
        }
      }

      customElements.define('ui-button', UIButton);
    </script>

    <script type="module">
      import {DOMRemoteReceiver} from '@remote-dom/core/receivers';
      import {
        ROOT_ID,
        NODE_TYPE_ELEMENT,
        MUTATION_TYPE_INSERT_CHILD,
        MUTATION_TYPE_UPDATE_TEXT,
        MUTATION_TYPE_UPDATE_PROPERTY,
        MUTATION_TYPE_REMOVE_CHILD,
      } from '@remote-dom/core';
      import {ThreadIframe} from '@quilted/threads';

      const root = document.querySelector('#root');
      const iframe = document.querySelector('#remote-iframe');
      const receiver = new DOMRemoteReceiver();
      receiver.connect(root);

      // Host-level allowlist: only permit `ui-button` elements to be inserted.
      // This wrapper filters incoming mutation records before forwarding them to
      // the receiver. Unknown tags are ignored.
      const allowedTags = new Set(['ui-button']);
      const allowedIds = new Set([ROOT_ID]);

      function collectIds(node) {
        // Collect ids for the node and any descendants
        const stack = [node];
        while (stack.length > 0) {
          const current = stack.pop();
          if (current && typeof current.id === 'string') {
            allowedIds.add(current.id);
          }
          if (current && current.children) {
            for (const child of current.children) stack.push(child);
          }
        }
      }

      function sanitizeNode(node) {
        // Keep text and comment nodes as-is
        if (node.type !== NODE_TYPE_ELEMENT) return node;

        // Drop disallowed element nodes entirely
        if (!allowedTags.has(node.element)) return null;

        // Rebuild the element with only sanitized children
        const sanitizedChildren = [];
        if (Array.isArray(node.children)) {
          for (const child of node.children) {
            const sanitized = sanitizeNode(child);
            if (sanitized) sanitizedChildren.push(sanitized);
          }
        }

        return {
          ...node,
          children: sanitizedChildren,
        };
      }

      const filteredConnection = {
        call: (...args) => receiver.connection.call(...args),
        mutate(records) {
          const filtered = [];

          for (const record of records) {
            const [type, ...rest] = record;

            if (type === MUTATION_TYPE_INSERT_CHILD) {
              const [parentId, child, index] = rest;

              // Only insert under an allowed parent, and only if the child node is allowed
              if (!allowedIds.has(parentId)) continue;
              const sanitized = sanitizeNode(child);
              if (!sanitized) continue;

              collectIds(sanitized);
              filtered.push([type, parentId, sanitized, index]);
              continue;
            }

            if (type === MUTATION_TYPE_UPDATE_TEXT) {
              const [id] = rest;
              if (!allowedIds.has(id)) continue;
              filtered.push(record);
              continue;
            }

            if (type === MUTATION_TYPE_UPDATE_PROPERTY) {
              const [id] = rest;
              if (!allowedIds.has(id)) continue;
              filtered.push(record);
              continue;
            }

            if (type === MUTATION_TYPE_REMOVE_CHILD) {
              const [parentId] = rest;
              if (!allowedIds.has(parentId)) continue;
              filtered.push(record);
              continue;
            }

            // Any other record types (future-proof): pass through
            filtered.push(record);
          }

          if (filtered.length > 0) receiver.connection.mutate(filtered);
        },
      };

      // We use the `@quilted/threads` library to create a ‚Äúthread‚Äù for our iframe,
      // which lets us communicate over `postMessage` without having to worry about
      // most of its complexities. This includes the ability to send functions between
      // environments, which we rely on for the `click` event listener.
      const thread = new ThreadIframe(iframe);

      // We will call the `render` method on the thread, which will send the iframe
      // the `receiver.connection` object. This object, called a `RemoteConnection`,
      // allows the remote environment to synchronize its tree of UI elements into
      // the `root` element we connected our `receiver` to above.
      thread.imports.render(filteredConnection);
    </script>
  </body>
</html>
